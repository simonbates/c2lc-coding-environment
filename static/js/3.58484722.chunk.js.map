{"version":3,"sources":["../node_modules/react-mic/es/libs/AudioContext.js","../node_modules/react-mic/es/libs/MicrophoneRecorder.js","../node_modules/react-mic/es/libs/AudioPlayer.js","../node_modules/react-mic/es/libs/Visualizer.js","../node_modules/react-mic/es/components/ReactMic.js","../node_modules/react-mic/es/index.js"],"names":["window","AudioContext","webkitAudioContext","createAnalyser","getAudioContext","getAnalyser","resetAnalyser","decodeAudioData","audioData","then","decodedData","mediaRecorder","chunks","startTime","stream","mediaOptions","onStartCallback","onStopCallback","onSaveCallback","onDataCallback","constraints","audio","video","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","MicrophoneRecorder","onStart","onStop","onSave","onData","options","_this","this","instance","Constructor","TypeError","_classCallCheck","startRecording","Date","now","state","resume","start","createMediaStreamSource","connect","mediaDevices","console","log","str","MediaRecorder","isTypeSupported","mimeType","onstop","ondataavailable","event","push","data","alert","prototype","stopRecording","stop","getAudioTracks","forEach","track","evt","blob","Blob","blobObject","stopTime","blobURL","URL","createObjectURL","audioSource","create","audioElem","audioCtx","analyser","undefined","source","createMediaElementSource","destination","visualizeSineWave","canvasCtx","canvas","width","height","backgroundColor","strokeColor","bufferLength","fftSize","dataArray","Uint8Array","clearRect","draw","requestAnimationFrame","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","y","moveTo","lineTo","stroke","visualizeFrequencyBars","self","frequencyBinCount","getByteFrequencyData","barWidth","barHeight","hexToRgb","visualizeFrequencyCircles","reducedDataArray","sum","j","arc","Math","min","PI","fill","stepSize","length","_i","r","hex","result","exec","parseInt","g","b","_Component","ReactMic","props","call","ReferenceError","_possibleConstructorReturn","visualize","_this$props","visualSetting","_this$state","microphoneRecorder","subClass","superClass","Object","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_inherits","componentDidMount","_this2","_props","audioBitsPerSecond","refs","visualizer","getContext","setState","clear","_props2","render","_props3","record","_state","createElement","ref","className","propTypes","defaultProps"],"mappings":"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","file":"static/js/3.58484722.chunk.js","sourcesContent":["var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\nvar analyser = audioCtx.createAnalyser();\nvar AudioContext = {\n  getAudioContext: function getAudioContext() {\n    return audioCtx;\n  },\n  getAnalyser: function getAnalyser() {\n    return analyser;\n  },\n  resetAnalyser: function resetAnalyser() {\n    analyser = audioCtx.createAnalyser();\n  },\n  decodeAudioData: function decodeAudioData() {\n    audioCtx.decodeAudioData(audioData).then(function (decodedData) {// use the decoded data here\n    });\n  }\n};\nexport default AudioContext;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport AudioContext from './AudioContext';\nvar analyser = void 0;\nvar audioCtx = void 0;\nvar mediaRecorder = void 0;\nvar chunks = [];\nvar startTime = void 0;\nvar stream = void 0;\nvar mediaOptions = void 0;\nvar blobObject = void 0;\nvar onStartCallback = void 0;\nvar onStopCallback = void 0;\nvar onSaveCallback = void 0;\nvar onDataCallback = void 0;\nvar constraints = {\n  audio: true,\n  video: false\n}; // constraints - only audio needed\n\nnavigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\nexport var MicrophoneRecorder = function () {\n  function MicrophoneRecorder(onStart, onStop, onSave, onData, options) {\n    var _this = this;\n\n    _classCallCheck(this, MicrophoneRecorder);\n\n    this.startRecording = function () {\n      startTime = Date.now();\n\n      if (mediaRecorder) {\n        if (audioCtx && audioCtx.state === 'suspended') {\n          audioCtx.resume();\n        }\n\n        if (mediaRecorder && mediaRecorder.state === 'paused') {\n          mediaRecorder.resume();\n          return;\n        }\n\n        if (audioCtx && mediaRecorder && mediaRecorder.state === 'inactive') {\n          mediaRecorder.start(10);\n          var source = audioCtx.createMediaStreamSource(stream);\n          source.connect(analyser);\n\n          if (onStartCallback) {\n            onStartCallback();\n          }\n\n          ;\n        }\n      } else {\n        if (navigator.mediaDevices) {\n          console.log('getUserMedia supported.');\n          navigator.mediaDevices.getUserMedia(constraints).then(function (str) {\n            stream = str;\n\n            if (MediaRecorder.isTypeSupported(mediaOptions.mimeType)) {\n              mediaRecorder = new MediaRecorder(str, mediaOptions);\n            } else {\n              mediaRecorder = new MediaRecorder(str);\n            }\n\n            if (onStartCallback) {\n              onStartCallback();\n            }\n\n            ;\n            mediaRecorder.onstop = _this.onStop;\n\n            mediaRecorder.ondataavailable = function (event) {\n              chunks.push(event.data);\n\n              if (onDataCallback) {\n                onDataCallback(event.data);\n              }\n            };\n\n            audioCtx = AudioContext.getAudioContext();\n            audioCtx.resume().then(function () {\n              analyser = AudioContext.getAnalyser();\n              mediaRecorder.start(10);\n              var sourceNode = audioCtx.createMediaStreamSource(stream);\n              sourceNode.connect(analyser);\n            });\n          });\n        } else {\n          alert('Your browser does not support audio recording');\n        }\n      }\n    };\n\n    onStartCallback = onStart;\n    onStopCallback = onStop;\n    onSaveCallback = onSave;\n    onDataCallback = onData;\n    mediaOptions = options;\n  }\n\n  MicrophoneRecorder.prototype.stopRecording = function stopRecording() {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n      mediaRecorder.stop();\n      stream.getAudioTracks().forEach(function (track) {\n        track.stop();\n      });\n      mediaRecorder = null;\n      AudioContext.resetAnalyser();\n    }\n  };\n\n  MicrophoneRecorder.prototype.onStop = function onStop(evt) {\n    var blob = new Blob(chunks, {\n      'type': mediaOptions.mimeType\n    });\n    chunks = [];\n    var blobObject = {\n      blob: blob,\n      startTime: startTime,\n      stopTime: Date.now(),\n      options: mediaOptions,\n      blobURL: window.URL.createObjectURL(blob)\n    };\n\n    if (onStopCallback) {\n      onStopCallback(blobObject);\n    }\n\n    ;\n\n    if (onSaveCallback) {\n      onSaveCallback(blobObject);\n    }\n\n    ;\n  };\n\n  return MicrophoneRecorder;\n}();","import AudioContext from './AudioContext';\nvar audioSource = void 0;\nvar AudioPlayer = {\n  create: function create(audioElem) {\n    var audioCtx = AudioContext.getAudioContext();\n    var analyser = AudioContext.getAnalyser();\n\n    if (audioSource === undefined) {\n      var source = audioCtx.createMediaElementSource(audioElem);\n      source.connect(analyser);\n      audioSource = source;\n    }\n\n    analyser.connect(audioCtx.destination);\n  }\n};\nexport default AudioPlayer;","import AudioContext from './AudioContext';\nvar drawVisual = void 0;\nvar Visualizer = {\n  visualizeSineWave: function visualizeSineWave(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\n    var analyser = AudioContext.getAnalyser();\n    var bufferLength = analyser.fftSize;\n    var dataArray = new Uint8Array(bufferLength);\n    canvasCtx.clearRect(0, 0, width, height);\n\n    function draw() {\n      drawVisual = requestAnimationFrame(draw);\n      analyser = AudioContext.getAnalyser();\n      analyser.getByteTimeDomainData(dataArray);\n      canvasCtx.fillStyle = backgroundColor;\n      canvasCtx.fillRect(0, 0, width, height);\n      canvasCtx.lineWidth = 2;\n      canvasCtx.strokeStyle = strokeColor;\n      canvasCtx.beginPath();\n      var sliceWidth = width * 1.0 / bufferLength;\n      var x = 0;\n\n      for (var i = 0; i < bufferLength; i++) {\n        var v = dataArray[i] / 128.0;\n        var y = v * height / 2;\n\n        if (i === 0) {\n          canvasCtx.moveTo(x, y);\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n\n        x += sliceWidth;\n      }\n\n      canvasCtx.lineTo(canvas.width, canvas.height / 2);\n      canvasCtx.stroke();\n    }\n\n    ;\n    draw();\n  },\n  visualizeFrequencyBars: function visualizeFrequencyBars(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\n    var self = this;\n    var analyser = AudioContext.getAnalyser();\n    analyser.fftSize = 256;\n    var bufferLength = analyser.frequencyBinCount;\n    var dataArray = new Uint8Array(bufferLength);\n    canvasCtx.clearRect(0, 0, width, height);\n\n    function draw() {\n      drawVisual = requestAnimationFrame(draw);\n      analyser = AudioContext.getAnalyser();\n      analyser.getByteFrequencyData(dataArray);\n      canvasCtx.fillStyle = backgroundColor;\n      canvasCtx.fillRect(0, 0, width, height);\n      var barWidth = width / bufferLength * 2.5;\n      var barHeight = void 0;\n      var x = 0;\n\n      for (var i = 0; i < bufferLength; i++) {\n        barHeight = dataArray[i];\n        var rgb = self.hexToRgb(strokeColor); // canvasCtx.fillStyle = `rgb(${barHeight+100},${rgb.g},${rgb.b})`;\n\n        canvasCtx.fillStyle = strokeColor;\n        canvasCtx.fillRect(x, height - barHeight / 2, barWidth, barHeight / 2);\n        x += barWidth + 1;\n      }\n    }\n\n    ;\n    draw();\n  },\n  visualizeFrequencyCircles: function visualizeFrequencyCircles(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\n    var self = this;\n    var analyser = AudioContext.getAnalyser();\n    analyser.fftSize = 32;\n    var bufferLength = analyser.frequencyBinCount;\n    var dataArray = new Uint8Array(bufferLength);\n    canvasCtx.clearRect(0, 0, width, height);\n\n    function draw() {\n      drawVisual = requestAnimationFrame(draw);\n      analyser = AudioContext.getAnalyser();\n      analyser.getByteFrequencyData(dataArray);\n      var reductionAmount = 3;\n      var reducedDataArray = new Uint8Array(bufferLength / reductionAmount);\n\n      for (var i = 0; i < bufferLength; i += reductionAmount) {\n        var sum = 0;\n\n        for (var j = 0; j < reductionAmount; j++) {\n          sum += dataArray[i + j];\n        }\n\n        reducedDataArray[i / reductionAmount] = sum / reductionAmount;\n      }\n\n      canvasCtx.clearRect(0, 0, width, height);\n      canvasCtx.beginPath();\n      canvasCtx.arc(width / 2, height / 2, Math.min(height, width) / 2, 0, 2 * Math.PI);\n      canvasCtx.fillStyle = backgroundColor;\n      canvasCtx.fill();\n      var stepSize = Math.min(height, width) / 2.0 / reducedDataArray.length;\n      canvasCtx.strokeStyle = strokeColor;\n\n      for (var _i = 0; _i < reducedDataArray.length; _i++) {\n        canvasCtx.beginPath();\n        var normalized = reducedDataArray[_i] / 128;\n        var r = stepSize * _i + stepSize * normalized;\n        canvasCtx.arc(width / 2, height / 2, r, 0, 2 * Math.PI);\n        canvasCtx.stroke();\n      }\n    }\n\n    ;\n    draw();\n  },\n  hexToRgb: function hexToRgb(hex) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : null;\n  }\n};\nexport default Visualizer;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // cool blog article on how to do this: http://www.smartjava.org/content/exploring-html5-web-audio-visualizing-sound\n// https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\n// distortion curve for the waveshaper, thanks to Kevin Ennis\n// http://stackoverflow.com/questions/22312841/waveshaper-node-in-webaudio-how-to-emulate-distortion\n\n\nimport React, { Component } from 'react';\nimport { string, number, bool, func } from 'prop-types';\nimport { MicrophoneRecorder } from '../libs/MicrophoneRecorder';\nimport AudioContext from '../libs/AudioContext';\nimport AudioPlayer from '../libs/AudioPlayer';\nimport Visualizer from '../libs/Visualizer';\n\nvar ReactMic = function (_Component) {\n  _inherits(ReactMic, _Component);\n\n  function ReactMic(props) {\n    _classCallCheck(this, ReactMic);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this.visualize = function () {\n      var self = _this;\n      var _this$props = _this.props,\n          backgroundColor = _this$props.backgroundColor,\n          strokeColor = _this$props.strokeColor,\n          width = _this$props.width,\n          height = _this$props.height,\n          visualSetting = _this$props.visualSetting;\n      var _this$state = _this.state,\n          canvas = _this$state.canvas,\n          canvasCtx = _this$state.canvasCtx;\n\n      if (visualSetting === 'sinewave') {\n        Visualizer.visualizeSineWave(canvasCtx, canvas, width, height, backgroundColor, strokeColor);\n      } else if (visualSetting === 'frequencyBars') {\n        Visualizer.visualizeFrequencyBars(canvasCtx, canvas, width, height, backgroundColor, strokeColor);\n      } else if (visualSetting === 'frequencyCircles') {\n        Visualizer.visualizeFrequencyCircles(canvasCtx, canvas, width, height, backgroundColor, strokeColor);\n      }\n    };\n\n    _this.state = {\n      microphoneRecorder: null,\n      canvas: null,\n      canvasCtx: null\n    };\n    return _this;\n  }\n\n  ReactMic.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _props = this.props,\n        onSave = _props.onSave,\n        onStop = _props.onStop,\n        onStart = _props.onStart,\n        onData = _props.onData,\n        audioElem = _props.audioElem,\n        audioBitsPerSecond = _props.audioBitsPerSecond,\n        mimeType = _props.mimeType;\n    var visualizer = this.refs.visualizer;\n    var canvas = visualizer;\n    var canvasCtx = canvas.getContext(\"2d\");\n    var options = {\n      audioBitsPerSecond: audioBitsPerSecond,\n      mimeType: mimeType\n    };\n\n    if (audioElem) {\n      AudioPlayer.create(audioElem);\n      this.setState({\n        canvas: canvas,\n        canvasCtx: canvasCtx\n      }, function () {\n        _this2.visualize();\n      });\n    } else {\n      this.setState({\n        microphoneRecorder: new MicrophoneRecorder(onStart, onStop, onSave, onData, options),\n        canvas: canvas,\n        canvasCtx: canvasCtx\n      }, function () {\n        _this2.visualize();\n      });\n    }\n  };\n\n  ReactMic.prototype.clear = function clear() {\n    var _props2 = this.props,\n        width = _props2.width,\n        height = _props2.height;\n    var canvasCtx = this.state.canvasCtx;\n    canvasCtx.clearRect(0, 0, width, height);\n  };\n\n  ReactMic.prototype.render = function render() {\n    var _props3 = this.props,\n        record = _props3.record,\n        onStop = _props3.onStop,\n        width = _props3.width,\n        height = _props3.height;\n    var _state = this.state,\n        microphoneRecorder = _state.microphoneRecorder,\n        canvasCtx = _state.canvasCtx;\n\n    if (record) {\n      if (microphoneRecorder) {\n        microphoneRecorder.startRecording();\n      }\n    } else {\n      if (microphoneRecorder) {\n        microphoneRecorder.stopRecording(onStop);\n        this.clear();\n      }\n    }\n\n    return React.createElement('canvas', {\n      ref: 'visualizer',\n      height: height,\n      width: width,\n      className: this.props.className\n    });\n  };\n\n  return ReactMic;\n}(Component);\n\nexport { ReactMic as default };\nReactMic.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  backgroundColor: string,\n  strokeColor: string,\n  className: string,\n  audioBitsPerSecond: number,\n  mimeType: string,\n  height: number,\n  record: bool.isRequired,\n  onStop: func,\n  onData: func\n} : {};\nReactMic.defaultProps = {\n  backgroundColor: 'rgba(255, 255, 255, 0.5)',\n  strokeColor: '#000000',\n  className: 'visualizer',\n  audioBitsPerSecond: 128000,\n  mimeType: 'audio/webm;codecs=opus',\n  record: false,\n  width: 640,\n  height: 100,\n  visualSetting: 'sinewave'\n};","import ReactMic from './components/ReactMic';\nexport { ReactMic };"],"sourceRoot":""}